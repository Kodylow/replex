use anyhow::Result;
use axum::extract::{Path, Query, State};
use axum::http::StatusCode;
use axum::Json;
use multimint::fedimint_ln_client::LightningClientModule;
use serde::{Deserialize, Serialize};
use tracing::info;
use url::Url;

use super::LnurlStatus;
use crate::error::AppError;
use crate::model::invoices::{InvoiceForCreate, InvoiceState};
use crate::state::AppState;
use crate::utils::lnurl::{
    create_callback_response, create_invoice, create_verify_url, subscribe_to_invoice,
    validate_amount,
};
use crate::utils::{empty_string_as_none, get_federation_and_client, spawn_invoice_subscription};

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LnurlCallbackParams {
    pub amount: u64, // User specified amount in MilliSatoshi
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub nonce: Option<String>, // Optional parameter used to prevent server response caching
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub comment: Option<String>, /* Optional parameter to pass the LN WALLET user's comment to
                      * LN SERVICE */
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub proofofpayer: Option<String>, // Optional ephemeral secp256k1 public key generated by payer
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub nostr: Option<String>, // Optional zap request
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LnurlCallbackSuccessAction {
    pub tag: String,
    pub message: String,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LnurlCallbackResponse {
    pub status: LnurlStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub pr: String, // BOLT11 invoice
    pub verify: Url,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success_action: Option<LnurlCallbackSuccessAction>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<String>>,
}

const MIN_AMOUNT: u64 = 1000;

#[axum_macros::debug_handler]
pub async fn handle_callback(
    Path(username): Path<String>,
    Query(params): Query<LnurlCallbackParams>,
    State(state): State<AppState>,
) -> Result<Json<LnurlCallbackResponse>, AppError> {
    info!("callback called with username: {}", username);
    validate_amount(params.amount)?;

    match state.db.users().get_by_name(&username).await? {
        Some(user) => {
            let (federation_id, client) = get_federation_and_client(&state, &user).await?;
            let ln = client.get_first_module::<LightningClientModule>();

            let tweak = user.last_tweak + 1;
            let (op_id, invoice, _) = create_invoice(&ln, &params, &user, tweak).await?;
            state.db.users().update_tweak(&user, tweak).await?;
            let invoice = InvoiceForCreate::builder()
                .op_id(op_id.fmt_full().to_string())
                .federation_id(federation_id.to_string())
                .app_user_id(user.id)
                .amount(params.amount as i64)
                .bolt11(invoice.to_string())
                .tweak(tweak)
                .state(InvoiceState::Pending)
                .build()?;
            let invoice = state.db.invoice().create(invoice).await?;

            let subscription = subscribe_to_invoice(&ln, op_id).await?;
            spawn_invoice_subscription(state.clone(), invoice.clone(), subscription).await?;

            let verify_url = create_verify_url(&username, &op_id)?;
            let response = create_callback_response(invoice.bolt11, verify_url)?;

            Ok(Json(response))
        }
        None => Err(AppError::new(
            StatusCode::NOT_FOUND,
            anyhow::anyhow!("User not found"),
        )),
    }
}
