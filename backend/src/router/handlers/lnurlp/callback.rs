use std::str::FromStr;
use std::time::Duration;

use anyhow::Result;
use axum::extract::{Path, Query, State};
use axum::http::StatusCode;
use axum::Json;
use futures::StreamExt;
use multimint::fedimint_client::oplog::UpdateStreamOrOutcome;
use multimint::fedimint_client::ClientHandleArc;
use multimint::fedimint_core::config::FederationId;
use multimint::fedimint_core::secp256k1::PublicKey;
use multimint::fedimint_core::task::spawn;
use multimint::fedimint_core::Amount;
use multimint::fedimint_ln_client::{LightningClientModule, LnReceiveState};
use multimint::fedimint_ln_common::lightning_invoice::{Bolt11InvoiceDescription, Description};
use multimint::fedimint_mint_client::MintClientModule;
use serde::{Deserialize, Serialize};
use tracing::{error, info};
use url::Url;

use super::LnurlStatus;
use crate::config::CONFIG;
use crate::error::AppError;
use crate::model::app_user::AppUser;
use crate::model::db::Db;
use crate::model::invoice::{Invoice, InvoiceState};
use crate::state::AppState;
use crate::utils::empty_string_as_none;

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LnurlCallbackParams {
    pub amount: u64, // User specified amount in MilliSatoshi
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub nonce: Option<String>, // Optional parameter used to prevent server response caching
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub comment: Option<String>, /* Optional parameter to pass the LN WALLET user's comment to
                      * LN SERVICE */
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub proofofpayer: Option<String>, // Optional ephemeral secp256k1 public key generated by payer
    #[serde(default, deserialize_with = "empty_string_as_none")]
    pub nostr: Option<String>, // Optional zap request
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LnurlCallbackSuccessAction {
    pub tag: String,
    pub message: String,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LnurlCallbackResponse {
    pub status: LnurlStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub pr: String, // BOLT11 invoice
    pub verify: Url,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success_action: Option<LnurlCallbackSuccessAction>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routes: Option<Vec<String>>,
}

const MIN_AMOUNT: u64 = 1000;

#[axum_macros::debug_handler]
pub async fn handle_callback(
    Path(username): Path<String>,
    Query(params): Query<LnurlCallbackParams>,
    State(state): State<AppState>,
) -> Result<Json<LnurlCallbackResponse>, AppError> {
    info!("callback called with username: {}", username);
    if params.amount < MIN_AMOUNT {
        return Err(AppError {
            error: anyhow::anyhow!("Amount < MIN_AMOUNT"),
            status: StatusCode::BAD_REQUEST,
        });
    }

    let sql = "SELECT * FROM app_users WHERE name = $1";
    let user = state.db.query_one::<AppUser>(sql, &[&username]).await?;
    let federation_id = FederationId::from_str(&user.federation_ids[0]).map_err(|e| {
        AppError::new(
            StatusCode::BAD_REQUEST,
            anyhow::anyhow!("Invalid federation_id for user {}: {}", user.name, e),
        )
    })?;

    let locked_clients = state.fm.clients.lock().await.clone();
    let client = locked_clients.get(&federation_id).ok_or_else(|| {
        AppError::new(
            StatusCode::BAD_REQUEST,
            anyhow::anyhow!("FederationId not found in multimint map"),
        )
    })?;

    let ln = client.get_first_module::<LightningClientModule>();

    let tweak = user.last_tweak + 1;

    let (op_id, invoice, _) = ln
        .create_bolt11_invoice_for_user_tweaked(
            Amount {
                msats: params.amount,
            },
            Bolt11InvoiceDescription::Direct(&Description::new(
                params
                    .comment
                    .unwrap_or("hermes address payment".to_string()),
            )?),
            None,
            PublicKey::from_str(&user.pubkey)?,
            tweak as u64,
            (),
            None,
        )
        .await?;

    let sql = "UPDATE app_users SET last_tweak = $1 WHERE id = $2";
    state.db.execute(sql, &[&tweak, &user.id]).await?;

    // insert invoice into db for later verification
    let sql = "INSERT INTO invoices (op_id, federation_id, app_user_id, amount, bolt11, tweak, state) VALUES ($1, $2, $3, $4, $5, $6, $7)";
    let invoice = Invoice {
        id: 0,
        op_id: op_id.fmt_full().to_string(),
        federation_id: federation_id.to_string(),
        app_user_id: user.id,
        amount: params.amount as i64,
        bolt11: invoice.to_string(),
        tweak,
        state: InvoiceState::Pending,
    };
    state
        .db
        .execute(
            sql,
            &[
                &invoice.op_id,
                &invoice.federation_id,
                &invoice.app_user_id,
                &(invoice.amount as i64),
                &invoice.bolt11,
                &invoice.tweak,
                &invoice.state,
            ],
        )
        .await?;

    // create subscription to operation
    let subscription = ln
        .subscribe_ln_receive(op_id)
        .await
        .expect("subscribing to a just created operation can't fail");

    spawn_invoice_subscription(state, invoice.clone(), subscription).await;

    let verify_url = format!(
        "http://{}:{}/lnurlp/{}/verify/{}",
        CONFIG.domain,
        CONFIG.port,
        username,
        op_id.fmt_full().to_string()
    );

    let res = LnurlCallbackResponse {
        pr: invoice.bolt11,
        success_action: None,
        status: LnurlStatus::Ok,
        reason: None,
        verify: verify_url.parse()?,
        routes: Some(vec![]),
    };

    Ok(Json(res))
}

pub(crate) async fn spawn_invoice_subscription(
    state: AppState,
    invoice: Invoice,
    subscription: UpdateStreamOrOutcome<LnReceiveState>,
) {
    spawn("waiting for invoice being paid", async move {
        let locked_clients = state.fm.clients.lock().await;
        let client = locked_clients
            .get(&FederationId::from_str(&invoice.federation_id).unwrap())
            .unwrap();
        let mut stream = subscription.into_stream();
        while let Some(op_state) = stream.next().await {
            match op_state {
                LnReceiveState::Canceled { reason } => {
                    error!("Payment canceled, reason: {:?}", reason);
                    let sql = "UPDATE invoices SET state = $1 WHERE op_id = $2";
                    state
                        .db
                        .execute(sql, &[&InvoiceState::Cancelled, &invoice.op_id])
                        .await
                        .expect("cancelling invoice can't fail");
                }
                LnReceiveState::Claimed => {
                    info!("Payment claimed");
                    let sql = "UPDATE invoices SET state = $1 WHERE op_id = $2";
                    state
                        .db
                        .execute(sql, &[&InvoiceState::Settled, &invoice.op_id])
                        .await
                        .expect("updating invoice state can't fail");
                    notify_user(client, &state.db, invoice)
                        .await
                        .expect("notifying user can't fail");
                    break;
                }
                _ => {}
            }
        }
    });
}

async fn notify_user(client: &ClientHandleArc, db: &Db, invoice: Invoice) -> Result<()> {
    let sql = "SELECT * FROM app_users WHERE id = $1";
    let user = db
        .query_one::<AppUser>(sql, &[&invoice.app_user_id])
        .await?;
    let mint = client.get_first_module::<MintClientModule>();
    let (operation_id, notes) = mint
        .spend_notes(
            Amount::from_msats(invoice.amount as u64),
            Duration::from_secs(604800),
            false,
            (),
        )
        .await?;

    todo!()
}
